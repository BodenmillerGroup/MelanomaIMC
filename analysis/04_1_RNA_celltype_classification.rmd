---
title: "04_1_RNA_celltype_classification"
author: "toobiwankenobi"
date: "2020-07-28"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

# Introduction

This script performs cell-type classification based on manually labelled cells. We will create increasing complexity for cell type labelling. Meaning, in a first layer (layer_1) we will only classify major cell types. We will then use some of those labelled cells (e.g. T cells) and generate a more fine grained annotation (layer_2) and this will continue until layer 3.

This script contains the classification of layer 1.

# Preparations

## Read in data 
First, we will read in the SingleCellExperiment object and load all libraries.

```{r read-sce, message=F}
library(caret)
library(scater)
library(tidyverse)
library(dittoSeq)
library(viridis)
library(doParallel)
```

## Load data

```{r}
sce <- readRDS("data/sce_RNA.rds")

# load all subsetted sce object from hierarchichal gating and combine them
path = "data/rna/new_classifier/"
file.names <- dir(path, pattern =".rds")

# loop through all files and combine sce objects
for(i in 1:length(file.names)){
  file <- readRDS(paste0(path,file.names[i]))
  if (i == 1){
    labelled_sce <- file
  }
  else {
    labelled_sce <- cbind(labelled_sce, file)
  }
}
```

## Duplicates

```{r}
# how many duplicates do we have?
ncol(labelled_sce[,duplicated(labelled_sce$cellID) == T]) / ncol(labelled_sce[,duplicated(labelled_sce$cellID) == F]) * 100

# remove duplicates (more than 1 label per cellID)
unique_labels <- labelled_sce[,duplicated(labelled_sce$cellID) == F]
```

## Add labels to SCE object

```{r read_labels}
label_vector <- rep("unlabelled", ncol(sce))
names(label_vector) <- colnames(sce)
label_vector[colnames(unique_labels)] <- unique_labels$cytomapper_CellLabel

# rename labeles
label_vector[label_vector == "CD68+"] <- "Macrophage"
label_vector[label_vector == "CD15+MPO+"] <- "Neutrophil"
label_vector[label_vector == "HLA-DR+CD68-"] <- "HLA-DR"
label_vector[label_vector == "CD3+CD8-CD134+"] <- "CD134+ Tcell"
label_vector[label_vector == "CD3+CD8-CD134-"] <- "CD134- Tcell"
label_vector[label_vector == "CD3+CD8+LAG3+"] <- "exhausted Tcytotoxic"
label_vector[label_vector == "CD3+CD8+LAG3-"] <- "Tcytotoxic"

# unique cell labels
unique(label_vector)

# add to sce
colData(sce)$layer_1_gated <- label_vector
```

## Create colour vector

Here, we will define a colour vector for the cell-types contained in layer 1.

```{r}
layer1_colours <- vector(length = length(unique(label_vector)))
names(layer1_colours) <- unique(label_vector)

layer1_colours["CD38"] <- "goldenrod2"
layer1_colours["HLA-DR"] <- "darkolivegreen4"
layer1_colours["Macrophage"] <- "green4"
layer1_colours["Neutrophil"] <- "blue1"
layer1_colours["CD134- Tcell"] <- "yellow"
layer1_colours["CD134+ Tcell"] <- "yellow4"
layer1_colours["Vasculature"] <- "red2"
layer1_colours["Stroma"] <- "tomato"
layer1_colours["Tcytotoxic"] <- "deepskyblue"
layer1_colours["exhausted Tcytotoxic"] <- "deeppink"
layer1_colours["Tumor"] <- "sienna4"
layer1_colours["unlabelled"] <- "gray"

# Save in SCE object
metadata(sce)$colour_vectors$layer_1 <- layer1_colours
```

## Quality control

In the next step, we will check the quality of the labels by:

1. checking how many cells contain multiple labels (see chunk 2)
2. how many cells of how many images are labeled
3. how balanced the classes are
4. if the selected cells actually express the markers that they are supposed to express


Next, we will check how many cells and how many images are labelled.

```{r quality-control-2}
# 2. How many cells of how many images are labelled

# Percent cells labelled
as_tibble(colData(sce)) %>% 
  summarise(labelled_cells = sum(layer_1_gated != "unlabelled")/n()) * 100

# Percent images labelled
as_tibble(colData(sce)) %>% 
  group_by(ImageNumber) %>%
  summarise(labelled_cells = sum(layer_1_gated != "unlabelled")) %>%
  ungroup() %>%
  summarise(labelled_images = sum(labelled_cells != 0)/n()) * 100


# Percent of cells labelled per image
as_tibble(colData(sce)) %>% 
  group_by(ImageNumber) %>%
  summarise(labelled_cells = sum(layer_1_gated != "unlabelled")/n(),
            number_cells = n()) %>%
  as.data.frame()
```

We will check how balanced the classes are across the images.

```{r quality-control-3}
# Total cells per class
as_tibble(colData(sce)) %>%
  group_by(layer_1_gated) %>%
  summarise(number_cells = n())

# Total cells per class and Sample
as_tibble(colData(sce)) %>%
  group_by(layer_1_gated, ImageNumber) %>%
  summarise(number_cells = n()) %>%
  as.data.frame() %>%
  head(.)
```

Now, we will check the expression of selected markers across the classes and visualize cell labels on tSNE.

```{r quality-control-4}
lab_sce <- sce[,sce$layer_1_gated != "unlabelled"]
agr_sce <- aggregateAcrossCells(lab_sce, ids = colData(lab_sce)[,c("ImageNumber", "layer_1_gated")], 
                                average = TRUE)
assay(agr_sce, "exprs") <- asinh(counts(agr_sce))
colnames(agr_sce) <- paste0(agr_sce$SampleId, "_", agr_sce$layer_1_gated)

# Define markers that were used for gating
cur_markers <- c("SMA", "CK5","CD38","HLADR","S100","Cadherin11","FAP","CD68", "CD134", "CD68",
                 "CD3", "Lag3", "PD1", "CD8", "SOX10", "CD31", "Mart1", "pRB", "CD15", "MPO")

# Non-scaled
dittoHeatmap(agr_sce[cur_markers,], assay = "exprs",
            annot.by = c("ImageNumber", "layer_1_gated"), 
            order.by = "layer_1_gated", cluster_rows = FALSE,
            scale = "none", heatmap.colors = viridis(100), 
            annotation_colors = list(layer_1_gated = metadata(sce)$colour_vectors$layer_1))

# Centered and scaled
dittoHeatmap(agr_sce[cur_markers,], assay = "exprs",
            annot.by = c("SampleId", "layer_1_gated"), 
            order.by = "layer_1_gated", cluster_rows = FALSE,
            annotation_colors = list(layer_1_gated = metadata(sce)$colour_vectors$layer_1),
            heatmap.colors = colorRampPalette(c("dark blue", "white", "dark red"))(100),
            breaks = seq(-3, 3, length.out = 101))

unlab_sce <- sce[,sce$layer_1_gated == "unlabelled"]

ggplot() +
  geom_point(aes(x = tSNE_1, y = tSNE_2, colour = layer_1_gated), 
             data = data.frame(tSNE_1 = reducedDim(unlab_sce, "TSNE_mnnCorrected")[,1],
                               tSNE_2 = reducedDim(unlab_sce, "TSNE_mnnCorrected")[,2],
                               layer_1_gated = colData(unlab_sce)$layer_1_gated)) +
    geom_point(aes(x = tSNE_1, y = tSNE_2, colour = layer_1_gated), size = 0.5, 
             data = data.frame(tSNE_1 = reducedDim(lab_sce, "TSNE_mnnCorrected")[,1],
                               tSNE_2 = reducedDim(lab_sce, "TSNE_mnnCorrected")[,2],
                               layer_1_gated = colData(lab_sce)$layer_1_gated)) +
  scale_color_manual(values = metadata(sce)$colour_vectors$layer_1) + 
  theme_bw()

ggplot() +
  geom_point(aes(x = tSNE_1, y = tSNE_2, colour = layer_1_gated), 
             data = data.frame(tSNE_1 = reducedDim(unlab_sce, "TSNE")[,1],
                               tSNE_2 = reducedDim(unlab_sce, "TSNE")[,2],
                               layer_1_gated = colData(unlab_sce)$layer_1_gated)) +
    geom_point(aes(x = tSNE_1, y = tSNE_2, colour = layer_1_gated), size = 0.5, 
             data = data.frame(tSNE_1 = reducedDim(lab_sce, "TSNE")[,1],
                               tSNE_2 = reducedDim(lab_sce, "TSNE")[,2],
                               layer_1_gated = colData(lab_sce)$layer_1_gated)) +
  scale_color_manual(values = metadata(sce)$colour_vectors$layer_1) + 
  theme_bw()

# Remove lymphoid structure image - consider this as outlying image
colData(sce)$layer_1_gated[grepl("10031446-THOR-VAR-TIS-01-PB_3", colnames(sce))] <- "unlabelled"

# Subset the SingleCellExperiment object again
lab_sce <- sce[,sce$layer_1_gated != "unlabelled"]
unlab_sce <- sce[,sce$layer_1_gated == "unlabelled"]
```

# Random Forrest Training

After quality control, we will now use a random forrest classifier to classify the remaining cells in the dataset. 

## Splitting by cell-types

In the first instance, we will split the labelled data based on their cell-types and irgnore from which images the calls come.
In the current setting most images have been labelled but in the future we want to have a closer look at how well cells ofnon-labelled images are classified.

### Train and validate the classifier

We will first split the labelled data into training and test (validation) data at a ratio of 70/30 train/test.

```{r split-data}
set.seed(1234)
trainIndex <- createDataPartition(factor(lab_sce$layer_1_gated), p = 0.75)
train_sce <- lab_sce[,trainIndex$Resample1]
test_sce <- lab_sce[,-trainIndex$Resample1]
```

Here, we will first use a 10-fold crossvalidation by partitioning the data randomly across the full dataset.
This process is repeated 5 times.
We will also use parallel processing for time reasons.
For the `randomForrest` classifier, we need to tune the `mtry` parameter - the number of variables sampled for each split.

```{r train-model, message = FALSE}
# Define seeds for parallel processing
# Per iteration, we evaluate 10 models while tuning mtry
set.seed(222)
seeds <- vector(mode = "list", length = 51)
for (i in 1:50) {
  seeds[[i]] <- sample.int(5000, 10)
}
seeds[[51]] <- sample.int(5000, 1)

fitControl <- trainControl(method = "repeatedcv",
                           repeats = 5,
                           number = 10,
                           seeds = seeds)

cl <- makePSOCKcluster(6, setup_strategy = "sequential")
registerDoParallel(cl)

set.seed(1234)
rffit <- train(x = t(assay(train_sce, "exprs")[!grepl("DNA|Histone", rownames(train_sce)),]), 
               y = factor(train_sce$layer_1_gated),
               method = "rf", ntree = 1000,
               tuneLength = 10,
               trControl = fitControl)
stopCluster(cl)

rffit
```

We will now have a look at the accuracy measures over iterations.
The only parameter that has been tuned is `mtry`.

```{r accuracy}
ggplot(rffit) + 
  geom_errorbar(data = rffit$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4)
```

We can also compute the confusion matrix:

```{r confusion-matrix}
confusionMatrix(rffit)
```

We will also look at the varible importance.

```{r variable-importance, fig.height = 15}
cur_varImp <- varImp(rffit)
plot(cur_varImp, top = 37)
```

Finally, we will validate the model using the test data.

```{r model-testing}
cur_pred <- predict(rffit, newdata = t(assay(test_sce, "exprs")[!grepl("DNA|Histone", rownames(lab_sce)),]))

cm <- confusionMatrix(data = cur_pred, reference = factor(test_sce$layer_1_gated))
cm

data.frame(cm$byClass) %>%
  mutate(class = sub("Class: ", "", rownames(cm$byClass))) %>%
  ggplot() + 
  geom_point(aes(1 - Specificity, Sensitivity, 
                 size = Detection.Rate,
                 fill = class),
             shape = 21) + 
  scale_fill_manual(values = metadata(sce)$colour_vectors$layer_1) + 
  theme_bw() + 
  ylab("Sensitivity (TPR)") +
  xlab("1 - Specificity (FPR)")
```

We will also observe the distribution of classification probabilities per image and class:

```{r prediciton-probability, fig.width = 15}
cur_pred <- predict(rffit, newdata = t(assay(test_sce, "exprs")[!grepl("DNA|Histone", rownames(lab_sce)),]), 
                    type = "prob")

cur_summary <- cur_pred %>%
  mutate(class = test_sce$layer_1_gated,
         sample = test_sce$SampleId,
         ROI = test_sce$ROI) %>%
  pivot_longer(cols = B_cell:Tumor) %>%
  filter(class == name) %>%
  ggplot() +
  geom_boxplot(aes(interaction(sample, ROI), value), outlier.size = 0.5) +
    facet_wrap(. ~ class) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

This plot shows the median probability for each image and class.
It indicates that tumor, T, CD38, Macrophages and Neutrophils have good classification probabilities

## Splitting by images

In the next step, we will try to simulate a scenario under which we will have to work future batches:
we will only be able to label cells from few images and need to classify unlabelled images. 

Now, we will partition the data based on the images using the `groupKFold` function form the `caret` package.

```{r grouped-fold-splitting}
set.seed(1234)
cur_folds <- groupKFold(lab_sce$ImageNumber, k = 10)
```

We can now use the folds as `index` argument in the `trainControl` function:

```{r model-2}
# Define seeds for parallel processing
# Per iteration, we evaluate 10 models while tuning mtry
set.seed(111)
seeds <- vector(mode = "list", length = 51)
for (i in 1:50) {
  seeds[[i]] <- sample.int(5000, 10)
}
seeds[[51]] <- sample.int(5000, 1)

fitControl <- trainControl(method = "repeatedcv",
                           repeats = 5,
                           index = cur_folds, 
                           savePredictions = "all",
                           seeds = seeds)

cl <- makePSOCKcluster(6, setup_strategy = "sequential")
registerDoParallel(cl)

set.seed(1234)
rffit2 <- train(x = t(assay(lab_sce, "exprs")[!grepl("DNA|Histone", rownames(train_sce)),]), 
               y = factor(lab_sce$layer_1_gated),
               method = "rf", ntree = 1000,
               tuneLength = 10,
               trControl = fitControl)
stopCluster(cl)

rffit2
```

As expected, fitting the model this way reduces accuracy.
We will now have a look at the accuracy measures over iterations.
The only parameter that has been tuned is `mtry`.

```{r accuracy}
ggplot(rffit2) + 
  geom_errorbar(data = rffit2$results,
                aes(ymin = Accuracy - AccuracySD,
                    ymax = Accuracy + AccuracySD),
                width = 0.4)
```

We can also compute the confusion matrix:

```{r confusion-matrix}
confusionMatrix(rffit2)
```

We will also look at the varible importance.

```{r variable-importance, fig.height = 15}
cur_varImp <- varImp(rffit2)
plot(cur_varImp, top = 37)
```

# Predicting new data

Finally, we will predict the labels of all other cells.
For cell-type classification, we will use the method that was trained across all images. 

```{r predict-cells}
cell_labels.class <- as.character(predict.train(rffit, 
                       newdata = t(assay(unlab_sce[!grepl("Histone|DNA", rownames(unlab_sce)),], "exprs")), 
                       type = "raw"))
cell_labels.prob <- predict.train(rffit, 
                       newdata = t(assay(unlab_sce[!grepl("Histone|DNA", rownames(unlab_sce)),], "exprs")), 
                       type = "prob")
```

Store predictions in SCE object.
We will not overwrite the labels of the already labelled cells.

```{r store-predictions}
cell_labels <- sce$layer_1_gated
cell_labels[colnames(unlab_sce)] <- cell_labels.class

sce$celltypes_layer1 <- cell_labels 
```

# Visualization

Here, we will visualize the predicted cell-types and their associated classification probabilities.

## Using reduced dimensions

```{r red-dim-visualization}
dittoDimPlot(sce[,sce$layer_1_gated != "unlabelled"], var = "celltypes_layer1", reduction.use = "TSNE", size = 0.5, 
              color.panel = metadata(sce)$colour_vectors$layer_1, main = "Cell types gated") 

dittoDimPlot(sce[,sce$layer_1_gated == "unlabelled"], var = "celltypes_layer1", reduction.use = "TSNE", size = 0.5, 
              color.panel = metadata(sce)$colour_vectors$layer_1, main = "Cell types classified") 

dittoDimPlot(sce[,sce$layer_1_gated != "unlabelled"], var = "celltypes_layer1", reduction.use = "TSNE_mnnCorrected", size = 0.5, 
              color.panel = metadata(sce)$colour_vectors$layer_1, main = "Cell types gated") 

dittoDimPlot(sce[,sce$layer_1_gated == "unlabelled"], var = "celltypes_layer1", reduction.use = "TSNE_mnnCorrected", size = 0.5, 
              color.panel = metadata(sce)$colour_vectors$layer_1, main = "Cell types classified") 

# Visualize on batch-corrected TSNE
# B cells
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$B_cell,
       class = cell_labels.class == "B_cell")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "B cell probability")

# CD38
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$CD38,
       class = cell_labels.class == "CD38")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "CD38 probability")

# DC
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$DC,
       class = cell_labels.class == "DC")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "DC probability")

# Macrophage
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$Macrophage,
       class = cell_labels.class == "Macrophage")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "Macrophage probability")

# Neutrophil
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$Neutrophil,
       class = cell_labels.class == "Neutrophil")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "Neutrophil probability")

# NK_cell
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$NK_cell,
       class = cell_labels.class == "NK_cell")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "NK cell probability")

# pDC
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$pDC,
       class = cell_labels.class == "pDC")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "pDC probability")

# Stroma
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$Stroma,
       class = cell_labels.class == "Stroma")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "Stroma probability")

# T_cell
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$T_cell,
       class = cell_labels.class == "T_cell")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "T_cell probability")

# Tumor
cur_df <- data.frame(tSNE1 = reducedDim(unlab_sce, "TSNE")[,1],
       tSNE2 = reducedDim(unlab_sce, "TSNE")[,2],
       prob = cell_labels.prob$Tumor,
       class = cell_labels.class == "Tumor")

ggplot() + geom_point(aes(tSNE1, tSNE2), data = cur_df[!cur_df$class,],
                       color = "gray") +
  geom_point(aes(tSNE1, tSNE2, color = prob), data = cur_df[cur_df$class,],
             size = 0.5)+
  scale_colour_viridis(name = "Tumor probability")
```

## Visualization of marker expression

Finally, we will visualize the marker expression per cell type using the classified cells.

```{r heatmap-visualization}
unlab_sce <- sce[,sce$layer_1_gated == "unlabelled"]
agr_sce <- aggregateAcrossCells(unlab_sce, ids = colData(unlab_sce)[,c("SampleId", "celltypes_layer1")], 
                                average = TRUE)
assay(agr_sce, "exprs") <- asinh(counts(agr_sce))
colnames(agr_sce) <- paste0(agr_sce$SampleId, "_", agr_sce$celltypes_layer1)

# Define markers that were used for gating
cur_markers <- c("Ecad", "CarbonicAnhydrase", "CD14", "HLADR", "CD11c", "CD303", "CD68", "CD15", "MPO", "CD38",
                 "SMA", "PDGFRb", "CD20", "CD7", "CD3")

# Non-scaled
dittoHeatmap(agr_sce[cur_markers,], assay = "exprs",
            annot.by = c("SampleId", "celltypes_layer1"), 
            order.by = "celltypes_layer1", cluster_rows = FALSE,
            scale = "none", heatmap.colors = viridis(100), 
            annotation_colors = list(SampleId = metadata(sce)$colour_vectors$SampleId,
                                     celltypes_layer1 = metadata(sce)$colour_vectors$layer_1))

# Centered and scaled
dittoHeatmap(agr_sce[cur_markers,], assay = "exprs",
            annot.by = c("SampleId", "celltypes_layer1"), 
            order.by = "celltypes_layer1", cluster_rows = FALSE,
            annotation_colors = list(SampleId = metadata(sce)$colour_vectors$SampleId,
                                     celltypes_layer1 = metadata(sce)$colour_vectors$layer_1),
            heatmap.colors = colorRampPalette(c("dark blue", "white", "dark red"))(100),
            breaks = seq(-3, 3, length.out = 101))
```

# Save RDS

```{r saveRDS}
saveRDS(sce, paste0(mount_path,
                    "processed_data/Panel_1/Batch20191023/IMMUcan_Batch20191023_panel_1_1_1.05/Rout/data/sce.rds"))

# create data frame with class and probabilities and save as csv.
layer_1_dat <- as.data.frame(cell_labels.prob)

layer_1_dat$class <- cell_labels.class

write.csv(layer_1_dat, 
          file = paste0(mount_path,"processed_data/Panel_1/Batch20191023/IMMUcan_Batch20191023_panel_1_1_1.05/Rout/data/layer_1_classification.csv"))
```
