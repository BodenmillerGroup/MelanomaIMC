---
title: "Figure 3"
author: "Tobias Hoch and Daniel Schulz"
date: "2020-08-04"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

# Introduction
This script generates plots for Figure 3.

# Preparations

```{r setup}
knitr::opts_chunk$set(echo = TRUE, message= FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

## Load libraries

First, we will load the libraries needed for this part of the analysis.

```{r load-libraries, message=FALSE}
sapply(list.files("code/helper_functions", full.names = TRUE), source)
library(SingleCellExperiment)
library(reshape2)
library(tidyverse)
library(dplyr)
library(umap)
library(data.table) 
library(fpc)
library(ggplot2)
library(cba)
library(ComplexHeatmap)
library(colorRamps)
library(circlize)
library(RColorBrewer)
library(ggbeeswarm)
library(destiny)
library(scater)
library(dittoSeq)
library(gridExtra)
library(ggpmisc)
library(neighbouRhood)
library(cowplot)
library(viridis)
library(ggpubr)
library(rstatix)
library(sf)
library(concaveman)
library(RANN)
```

## Read the data

```{r load data}
sce_rna = readRDS(file = "data/data_for_analysis/sce_RNA.rds")
sce_prot = readRDS(file = "data/data_for_analysis/sce_protein.rds")

# meta data
dat_relation = fread(file = "data/data_for_analysis/rna/Object relationships.csv",stringsAsFactors = FALSE)
```

## Prepare Relation Table

```{r}
# prepare data 
dat_relation$cellID_first <- paste("RNA", paste(dat_relation$`First Image Number`, dat_relation$`First Object Number`, sep = "_"), sep = "_")
dat_relation$cellID_second <- paste("RNA", paste(dat_relation$`Second Image Number`, dat_relation$`Second Object Number`, sep = "_"), sep = "_")
```

# Figure 3B

## CP output

```{r}
# Load and prepare
dat_cells = fread(file = "data/data_for_analysis/rna/cell.csv",stringsAsFactors = FALSE)
dat_relation = fread(file = "data/data_for_analysis/rna/Object relationships.csv",stringsAsFactors = FALSE)

# Number of cores used for multicore:
if(detectCores() >= 12){
  ncores = round(detectCores()/1.25,0)
}
if(detectCores() > 1 & detectCores() < 12){
  ncores = round(detectCores()/2,0)
}
if(detectCores() == 1){
  ncores = 1
}

n_perm = 100 
```

## Start the analysis

```{r milieu_analysis}
start = Sys.time()
cur_sce <- as.data.frame(colData(sce_rna))

# add same cellID to dat_cells as in sce object
dat_cells$cellID <- paste("RNA_", paste(dat_cells$ImageNumber, dat_cells$ObjectNumber, sep = "_"), sep = "")

image_df <- data.frame()
for(size in c(2,3,4,5,6)) {
  images <- data.frame()
  for(i in colnames(cur_sce[,grepl("CCL|CXCL",colnames(cur_sce))])){
    # add chemokine info to celltype
    sce_info <- cur_sce[,c("cellID", i , "Description")]
    
    # add celltype information
    dat_cells_tmp <- left_join(as.data.frame(dat_cells), sce_info, by = "cellID")
    
    #assign labels and groups
    dat_cells_tmp$label <- dat_cells_tmp[,i]
    dat_cells_tmp$group <- dat_cells_tmp$Description
    dat_cells_tmp <- as.data.table(dat_cells_tmp)
    
    # subset dat_relation and dat_cells
    dat_cells_sub <- dat_cells_tmp#[dat_cells$Description == "P3",]
    dat_relation_sub <- dat_relation#[dat_relation$`First Image Number` == unique(sce_rna[,sce_rna$Description == "P3"]$ImageNumber),]
    
    # Prepare the data
    d = neighbouRhood::prepare_tables(dat_cells_sub, dat_relation_sub)
    
    # Calculate the baseline statistics
    dat_baseline = neighbouRhood::apply_labels(d[[1]], d[[2]]) %>%
      neighbouRhood::aggregate_classic_patch(., patch_size = size)
    
    # Calculate the permutation statistics
    # This will run the test using parallel computing. The name of the idcol does actually not matter.
    
    set.seed(12312)
    dat_perm = rbindlist(mclapply(1:n_perm, function(x){
      dat_labels = neighbouRhood::shuffle_labels(d[[1]])
      neighbouRhood::apply_labels(dat_labels, d[[2]]) %>%
        neighbouRhood::aggregate_classic_patch(., patch_size = size)
    },mc.cores = ncores
    ), idcol = 'run')
    
    # calc p values
    dat_p <- neighbouRhood::calc_p_vals(dat_baseline, dat_perm, n_perm = n_perm, p_tresh = 0.01) 
    
    # select interactions between chemokine+ cells
    dat_p$interaction <- paste(dat_p$FirstLabel, dat_p$SecondLabel, sep = "_")
    
    dat_p_wide <- dat_p %>%
      reshape2::dcast(group ~ interaction, value.var = "sigval", fill = 0) %>%
      select(group, `1_1`)
    
    summary <- as.data.frame(dat_p_wide) %>%
      group_by(`1_1`) %>%
      summarise(n=n(),.groups = 'drop') %>%
      ungroup() %>%
      mutate(percentage_sig = (n/sum(n)) * 100)
    
    images <- rbind(images, cbind(summary[1,], i))
  }
  
  # calculate percentage of images with significant patches
  images$percentage_sig <- 100 - images$percentage_sig
  images$patch_size <- size
  images <- select(images, percentage_sig, i, patch_size)
  colnames(images) <- c("significant_images", "chemokine", "patch_size")
  
  # add to data.frame
  image_df <- rbind(image_df, images)
}
end = Sys.time()

print(end-start)
```

## Visualize 

```{r Fig_3B_patch_analysis, dev=("pdf"), fig.height=5, fig.width=8}
dat <- image_df %>%
  reshape2::dcast(chemokine ~ patch_size, value.var = "significant_images", fill = 0)

rownames(dat) <- dat$chemokine
dat$chemokine <- NULL

m <- t(as.matrix(dat))

col_fun = viridis::inferno(100)

Heatmap(m,
        cluster_rows = FALSE,
        col = col_fun,
        column_title = "Self-Interaction",
        column_title_side = "bottom",
        show_row_names = TRUE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(sprintf("%.1f", m[i, j]), x, y, gp = gpar(fontsize = 15, col = "grey"))
          },
        heatmap_legend_param = list(
          title = "% Significant\nImages", at = c(0, 10, 20, 30, 40, 50),
          labels = c("0%", "10%", "20%", "30%","40%", "50%")),
        row_title = "Patch Size",
        row_names_side = "left",
        width = unit(15, "cm"),
        height = unit(8, "cm"))
```

## Calculate p-value for Figure 3B

```{r milieu_analysis_image58}
start = Sys.time()
cur_sce <- as.data.frame(colData(sce_rna))

image_df <- data.frame()
for(size in c(2,3,4,5,6,7,8,9,10)) {
  images <- data.frame()
  for(i in c("CXCL10")){
    # add chemokine info to celltype
    sce_info <- cur_sce[,c("cellID", i , "Description")]
    
    # add celltype information
    dat_cells_tmp <- left_join(as.data.frame(dat_cells), sce_info, by = "cellID")
    
    #assign labels and groups
    dat_cells_tmp$label <- dat_cells_tmp[,i]
    dat_cells_tmp$group <- dat_cells_tmp$Description
    dat_cells_tmp <- as.data.table(dat_cells_tmp)
    
    # subset dat_relation and dat_cells
    dat_cells_sub <- dat_cells_tmp[Description == "P3",]
    dat_relation_sub <- dat_relation[dat_relation$`First Image Number` == unique(sce_rna[,sce_rna$Description == "P3"]$ImageNumber),]
    
    # Prepare the data
    d = neighbouRhood::prepare_tables(dat_cells_sub, dat_relation_sub)
    
    # Calculate the baseline statistics
    dat_baseline = neighbouRhood::apply_labels(d[[1]], d[[2]]) %>%
      neighbouRhood::aggregate_classic_patch(., patch_size = size)
    
    # Calculate the permutation statistics
    # This will run the test using parallel computing. The name of the idcol does actually not matter.
    
    set.seed(12312)
    dat_perm = rbindlist(mclapply(1:n_perm, function(x){
      dat_labels = neighbouRhood::shuffle_labels(d[[1]])
      neighbouRhood::apply_labels(dat_labels, d[[2]]) %>%
        neighbouRhood::aggregate_classic_patch(., patch_size = size)
    },mc.cores = ncores
    ), idcol = 'run')
    
    # calc p values
    dat_p <- neighbouRhood::calc_p_vals(dat_baseline, dat_perm, n_perm = n_perm, p_tresh = 0.01) 
    
    # select interactions between chemokine+ cells
    dat_p$interaction <- paste(dat_p$FirstLabel, dat_p$SecondLabel, sep = "_")
    images <- rbind(images,dat_p)
  }
  
  # calculate percentage of images with significant patches
  images$patch_size <- size
  
  # add to data.frame
  image_df <- rbind(image_df, images)
}

end = Sys.time()
print(end-start)

# Significant Self-Interatcions
image_df[image_df$interaction == "1_1",]
```

# Figure 3C

## Example of CXCL10 Cluster and corresponding Community

```{r Fig_3C_clusters_and_communities, fig.width=10, fig.height=10, dev=c('pdf')}
example <- findPatch(sce_rna[,sce_rna$ImageNumber == 58], sce_rna[,sce_rna$CXCL10 == 1]$cellID, 
                    'cellID', 
                    'Center_X', 'Center_Y', 
                    'ImageNumber', 
                    distance = 20, 
                    min_clust_size = 10,
                    output_colname = "example_cluster")

example <- findMilieu(example, 
              'cellID', 
              'Center_X', 'Center_Y', 
              'ImageNumber', 
              'example_cluster', 
              distance = 25,
              output_colname = "chemokine_community_i",
              plot = TRUE)
```

## Zoom-in plot for patch/milieu

```{r Fig_3B_clusters_and_communities_zoom, fig.width=10, fig.height=10, dev=c('pdf')}
example <- findPatch(sce_rna[,sce_rna$ImageNumber == 58], sce_rna[,sce_rna$CXCL10 == 1]$cellID, 
                    'cellID', 
                    'Center_X', 'Center_Y', 
                    'ImageNumber', 
                    distance = 20, 
                    min_clust_size = 10,
                    output_colname = "example_cluster")

example <- findMilieu(example, 
              'cellID', 
              'Center_X', 'Center_Y', 
              'ImageNumber', 
              'example_cluster', 
              distance = 25,
              output_colname = "chemokine_community_i",
              plot = TRUE,
              xlim = c(725,850),
              ylim = c(500,675),
              point_size = 14)
```

# Figure 3D

## Chemokine-producing cells in Patches

```{r Fig_3D_sunburst_plot, fig.height=15, fig.width=10, dev=c('pdf')}
# define fractions of chemokines present in community
cur_dt <- data.frame(colData(sce_rna))

plot_list <- list()

for(i in names(cur_dt[,grepl(glob2rx("*pure"),names(cur_dt))])) {
  chemokine_name <- toupper(str_split(i, "_")[[1]][1])
  
  # select all cells that are in a milieu
  unique_comms <- unique(cur_dt[cur_dt[,i] > 0,i])
  cur_dt_sub <- cur_dt[cur_dt[,i] %in% unique_comms,]
  
  cur_dt_sub <- cbind(cur_dt_sub[,i],
                      cur_dt_sub[,grepl(glob2rx("C*L*"),names(cur_dt_sub))])
  
  colnames(cur_dt_sub)[1] <- i
  
  # add celltype and MM_location_simplified
  cur_dt_sub$cellID <- rownames(cur_dt_sub)
  cur_dt_sub <- left_join(cur_dt_sub, cur_dt[,c("cellID", "celltype", "MM_location_simplified")])
  
  # melt the table
  cur_dt_sub <- cur_dt_sub %>%
    reshape2::melt(id.vars = c("cellID", "celltype", "MM_location_simplified", i), variable.name = "chemokine", value.name = "status")
  
  # all cells that do not produce a chemokine
  non_producer <- cur_dt_sub %>%
    group_by(cellID) %>%
    summarise(sum = sum(status)) %>%
    filter(sum == 0) %>%
    select(cellID)
  
  # all cells that produce a chemokine - regardless of what chemokine
  producer <- cur_dt_sub %>%
    group_by(cellID) %>%
    summarise(sum = sum(status)) %>%
    filter(sum > 0) %>%
    select(cellID)
  
  # select non-producing cells and count
  non_producer <- cur_dt_sub[cur_dt_sub$cellID %in% non_producer$cellID,] %>%
    distinct(cellID, .keep_all = TRUE) %>%
    group_by(celltype, MM_location_simplified, chemokine) %>%
    summarise(n=n())
  
  non_producer$chemokine <- "no chemokine"
  
  # select producing cells and count chemokines
  producer <- cur_dt_sub[cur_dt_sub$cellID %in% producer$cellID,] %>%
    filter(status == 1) %>%
    group_by(celltype, MM_location_simplified, chemokine) %>%
    summarise(n=n())
  
  summary <- rbind(producer, non_producer)
  
  # celltypes numbers
  summary_celltypes <- summary %>%
    group_by(celltype) %>%
    summarise(n=sum(n)) 
  
  # chemokines per celltype numbers
  summary_chemokines <- summary %>%
    group_by(celltype, chemokine) %>%
    summarise(n=sum(n))
  
  # color_vector for cells and chemokines
  col_vector_cells <- metadata(sce_rna)$colour_vector$celltype
  col_vector_chemokines <- metadata(sce_rna)$colour_vectors$chemokine_single
  col_vector <- c(col_vector_cells, col_vector_chemokines)
  # add "no chemokine" to col_vector
  col_vector <- c(col_vector, "white")
  names(col_vector) <- c(names(col_vector[-length(col_vector)]), "no chemokine")
  
  # create labels for middle of sunburst plot
  
  # Number of detected Patches
  numberOfPatches <- paste(length(unique_comms), ifelse(length(unique_comms)>1," Milieus", " Milieu"), sep = "")
  
  # Median Number of Chemokine XY Producing Cells in a Patch
  medianCells <- cur_dt[cur_dt[,i] > 0 & cur_dt[,chemokine_name] == 1,] %>%
    group_by_at(i) %>%
    summarise(n=n()) %>%
    mutate(median = median(n))
  medianCells <- paste(round(unique(medianCells$median)), " Cells", sep = "")
    
  # Percentage of chemokines produced by milieu cells 
  percentageInPatches <- cur_dt[cur_dt[,chemokine_name] == 1,] %>%
    mutate(in_patch = ifelse(.[,i] > 0, 1, 0)) %>%
    group_by(in_patch) %>%
    summarise(n=n()) %>%
    mutate(percentage = n / sum(n) * 100) %>%
    filter(in_patch == 1)
  percentageInPatches <- paste(round(unique(percentageInPatches$percentage)), "%", sep = "")
  
  label <- paste(paste(numberOfPatches, medianCells, sep = "\n"), percentageInPatches, sep = "\n")
  
  # sunburst plot
  plt <- ggplot() + 
    geom_text(aes(x=0,y=0, label = label, size=1)) +
    geom_col(aes(x = 2, y = n, fill = celltype), 
           data = summary_celltypes, 
           color = "white",
           lwd = 1) + 
    geom_col(aes(x = 3, y = n, group = celltype, fill = chemokine), 
           data = summary_chemokines) +
    xlim(0, 3.5) + labs(x = NULL, y = NULL) + 
    scale_fill_manual(values = unname(col_vector),
                        breaks = names(col_vector),
                        labels = names(col_vector)) + 
    ggtitle(chemokine_name) +
    theme_void() +
    theme(axis.ticks=element_blank(),
          plot.margin = unit(c(0,0,0,0), "cm"),
          axis.text=element_blank(),
          axis.title=element_blank(),
          legend.position = "none",
          text = element_text(size = 18),
          plot.title = element_text(hjust = 0.5)) +
        coord_polar(theta = "y")
  
  # add to list
  plot_list[[i]] <- plot_grid(plt)

}

# plot sunburst plots (without CCL4, CCL22, CCL8 - low abundance communities)
plot_grid(plot_list$cxcl8_pure, plot_list$ccl2_pure, 
          plot_list$cxcl10_pure, plot_list$cxcl9_pure,
          plot_list$ccl18_pure, plot_list$ccl19_pure,
          plot_list$cxcl12_pure, plot_list$cxcl13_pure, 
          plot_list$ccl4_pure, plot_list$ccl22_pure,
          plot_list$ccl8_pure, 
          ncol = 3, aligh = "hv")
```

## Legend for Plot

```{r Fig_3C_Legend, dev=c('pdf'), fig.width=3, fig.height=5}
# create legend for chemokines
lgd1 = Legend(labels = names(col_vector_chemokines), title = "Outer Circle\nChemokine", legend_gp = gpar(fill = unname(col_vector_chemokines)))

# create legend for celltypes
lgd2 = Legend(labels = names(col_vector_cells), title = "Inner Circle\nCell Type ", legend_gp = gpar(fill = unname(col_vector_cells)))

draw(packLegend(lgd2, lgd1, direction = "horizontal"))
```

# Figure 3E

## Expression levels in CD8 cells in milieus

```{r}
milieus <- data.frame(colData(sce_rna)) %>%
  filter(celltype == "Tcytotoxic") %>%
  select(cellID, contains("pure")) %>%
  mutate_if(is.numeric, ~1 * (. > 0))

milieus$number_of_milieus <- rowSums(milieus[,-1])

# keep Tcytotoxics that are part of at least one milieu
milieus <- milieus %>%
  filter(number_of_milieus > 0) %>%
  select(-number_of_milieus) %>%
  reshape2::melt(id.vars = "cellID", variable.name = "milieu", value.name = "is_part") %>%
  filter(is_part > 0) %>%
  select(cellID, milieu)
```

## Marker Profile for different Milieus (for CD8+)

```{r Fig_3E_cd8_profile_milieus, fig.height=6, fig.width=8, dev=c('pdf')}
marker_rna <- c("Lag3", "T8_CXCL13", "T5_CCL4")

# rna data 
dat_rna <- data.frame(t(assay(sce_rna[marker_rna, sce_rna$celltype == "Tcytotoxic"], "asinh")))
dat_rna$cellID <- rownames(dat_rna)
dat_rna <- left_join(milieus, dat_rna)

# melt
dat_rna <- dat_rna %>%
  reshape2::melt(id.vars = c("cellID", "milieu"), variable.name = "channel", value.name = "asinh")

# remove CCL4/CCL8/CXCL8 milieus due to too few data points
dat_rna <- dat_rna %>%
  filter(!(milieu %in% c("ccl4_pure", "ccl8_pure", "cxcl8_pure")))

# rename milieus
dat_rna <- dat_rna %>%
  mutate(milieu_short = toupper(str_split(milieu, "_",  n = 2, simplify = TRUE)[,1]))

col_vector_chemokines <- metadata(sce_rna)$colour_vectors$chemokine_single

# add channel medium
dat_rna <- dat_rna %>%
  group_by(channel) %>%
  mutate(channel_median = median(asinh))

# one-sample t test
stat.test <- data.frame()

# loop through all channels (each has a different µ)
for(j in unique(dat_rna$channel)){
  cur.mu <- unique(dat_rna[dat_rna$channel == j, ]$channel_median)
  
  # calculate p-value for different milieus in one channel and adjust pvalue 
  cur.test <- dat_rna[dat_rna$channel == j, ] %>%
    group_by(channel, milieu_short) %>%
    t_test(asinh ~ 1, mu = cur.mu, detailed = TRUE) %>%
    adjust_pvalue()
      
  stat.test <- rbind(stat.test, cur.test)
}

# adjust again for testing across different channels
stat.test <- stat.test %>%
    adjust_pvalue() %>%
    add_significance("p.adj")

# plot
plot_list <- list()
ylim_list <- list("Lag3" = c(0,0.9), "T8_CXCL13" = c(0,2.3), "T5_CCL4" = c(0,1))
for(i in unique(dat_rna$channel)){
  cur.stat.test <- stat.test[stat.test$channel == i, ]
  
  plot_list[[i]] <- ggplot(dat_rna[dat_rna$channel == i,], aes(x=milieu_short, y=asinh, fill=milieu_short)) + 
    geom_boxplot(alpha=.6, lwd=0.5, outlier.shape = NA, position = position_dodge(1.1)) +
    theme_bw() +
    theme(text = element_text(size=18),
          axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank()) +
    guides(fill=guide_legend("Milieu", override.aes = list(alpha=1)), col="none") +
    stat_pvalue_manual(
      cur.stat.test, x = "milieu_short", y.position = ylim_list[[i]][2]-0.05,
      label = "p.adj.signif",
      position = position_dodge(0.8), 
      size=4) + 
    ylab("Mean Expression (asinh)") + 
    xlab("") + 
    geom_hline(aes(yintercept = channel_median, group = channel), colour = 'black', linetype = 2, size=1) + 
    scale_fill_manual(values = unname(col_vector_chemokines),
                      breaks = names(col_vector_chemokines),
                      labels = names(col_vector_chemokines)) + 
    coord_cartesian(ylim=ylim_list[[i]]) +
    facet_wrap(~channel)
}

leg_c <- cowplot::get_legend(plot_list[[1]])

grid.arrange(plot_list[[1]] + theme(legend.position = "none"),
             plot_list[[2]] + theme(legend.position = "none") + ylab(""),
             plot_list[[3]] + theme(legend.position = "none") + ylab(""),
             ncol=2)
```

## Legend

```{r Fig_3E_legend, fig.height=3, fig.width=2, dev=c('pdf')}
grid.arrange(leg_c)
```
