---
title: "Supplementary Figure 6"
author: "Tobias Hoch and Daniel Schulz"
date: "2021-09-22"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

# Introduction
This script generates plots for Supplementary Figure 6. 

# Preparations 

## Load libraries

```{r}
library(SingleCellExperiment)
library(gridExtra)
library(grid)
library(ggplot2)
library(dplyr)
```

# Protein Gates

## Load data

```{r}
sce_full <- readRDS("data/data_for_analysis/sce_protein.rds")
# take panel_meta because there are the channel names from the shiny output (and only there, not in the SCE)
panel_meta <- read.csv(file = "data/data_for_analysis/protein/melanoma_1.06_protein.csv", 
                       sep= ",",  stringsAsFactors = FALSE )
```

## Select one random file per celltype and load file

```{r}
# load all subsetted sce object from hierarchichal gating and combine the
label.files <- list.files("data/data_for_analysis/protein/celltype_classifier", full.names = TRUE)
file_names <- data.frame(path = label.files)
file_names$fileName <- sub(".*/", "", label.files)
file_names$celltype <- sub("\\_.*", "", file_names$fileName)

# select one random file per celltype
file_names <- file_names %>%
  group_by(celltype) %>%
  sample_n(1)

# Read in SCE objects
cur_sces <- lapply(file_names$path, readRDS)
```

## Print gating scheme - Protein

```{r Supp_Fig_6A_gating_scheme_protein, fig.height=10, fig.width=5, dev=("pdf")}
for(element in cur_sces){
  # current labelled sce object
  sce_label <- element
  cur_celltype <- unique(sce_label$cytomapper_CellLabel)
  # select all gates from metadata
  gates <- metadata(sce_label)[grepl("cytomapper_gate_", names(metadata(sce_label)))]
  cur_img <- gates[[1]]$img_id
  # subset sce to current image 
  cur_sce <- sce_full[,sce_full$ImageNumber == cur_img]
  plots <- list()
  
  for(i in names(gates)) {
    plots[[i]] <- local({
      # select gates and imageID
      cur_gate <- as.data.frame(gates[[i]]$gate)
      cur_img <- gates[[i]]$img_id
      
      # names of channels (complicated because shiny has different channel names than SCE)
      x_gate <- rownames(cur_gate)[1]
      y_gate <- rownames(cur_gate)[2]
      x_metal <- panel_meta[panel_meta$Target == x_gate, "Metal.Tag"]
      y_metal <- panel_meta[panel_meta$clean_target == y_gate, "Metal.Tag"]
      x_original <- rownames(rowData(cur_sce)[rowData(cur_sce)[,"Metal.Tag"] == x_metal,])
      y_original <- rownames(rowData(cur_sce)[rowData(cur_sce)[,"Metal.Tag"] == y_metal,])
      
      # select current channels
      cur_counts <- as.data.frame(t(assay(cur_sce, "asinh")[c(x_original, y_original),]))
      
      # check if cells are in gate
      cur_counts$in_gate <- ifelse(cur_counts[,1] >= cur_gate[1,1] &
                                     cur_counts[,1] <= cur_gate[1,2] &
                                     cur_counts[,2] >= cur_gate[2,1] &
                                     cur_counts[,2] <= cur_gate[2,2], TRUE, FALSE)
      
      # cellIDs of cells in gate (for next gate)
      cur_cells <- rownames(cur_counts[cur_counts$in_gate == TRUE,])
      
      # update cur_sce
      cur_sce <- cur_sce[,cur_sce$cellID %in% cur_cells]
      
      # plot
      p <- ggplot() +
        geom_point(data=cur_counts, aes(x=cur_counts[,1], y=cur_counts[,2], 
                                        color=ifelse(cur_counts[,"in_gate"] == TRUE, "red", "black")),
                   alpha=ifelse(cur_counts[,"in_gate"] == TRUE, 0.5,0.1)) +
        geom_rect(data = cur_gate, aes(xmin=cur_gate[1,1], xmax=cur_gate[1,2], ymin=cur_gate[2,1],
                                       ymax=cur_gate[2,2]),
                  color="black", alpha=0.2) +
        xlab(x_gate) +
        ylab(y_gate) +
        scale_color_identity() +
        theme_bw() +
        theme(legend.position = "none") 
      p
    })
  }
  
  n <- length(plots)
  nCol <- floor(sqrt(n))
  do.call("grid.arrange", c(plots, ncol=nCol, top=cur_celltype))
}
```

# RNA Gates

## Load data

```{r}
sce_full <- readRDS("data/data_for_analysis/sce_rna.rds")
# take panel_meta because there are the channel names from the shiny output (and only there, not in the SCE)
panel_mat <- read.csv(file = "data/data_for_analysis/rna/panel_mat.csv", stringsAsFactors = FALSE )
```

## Select one random file per celltype and load file

```{r}
# load all subsetted sce object from hierarchichal gating and combine the
label.files <- list.files("data/data_for_analysis/rna/celltype_classifier", full.names = TRUE)
file_names <- data.frame(path = label.files)
file_names$fileName <- sub(".*/", "", label.files)
file_names$celltype <- sub("\\_.*", "", file_names$fileName)

# select one random file per celltype
file_names <- file_names %>%
  group_by(celltype) %>%
  sample_n(1)

# Read in SCE objects
cur_sces <- lapply(file_names$path, readRDS)
```

## Print gating scheme

```{r Supp_Fig_6B_gating_scheme_rna, fig.height=10, fig.width=5, dev=("pdf")}
for(element in cur_sces){
  # current labelled sce object
  sce_label <- element
  cur_celltype <- unique(sce_label$cytomapper_CellLabel)
  # select all gates from metadata
  gates <- metadata(sce_label)[grepl("cytomapper_gate_", names(metadata(sce_label)))]
  cur_img <- gates[[1]]$img_id
  # subset sce to current image 
  cur_sce <- sce_full[,sce_full$ImageNumber == cur_img]
  plots <- list()
  
  for(i in names(gates)) {
    if(nrow(gates[[i]]$gate) == 1) next
    plots[[i]] <- local({
      # select gates and imageID
      cur_gate <- as.data.frame(gates[[i]]$gate)
      cur_img <- gates[[i]]$img_id
      
      # names of channels (complicated because shiny has different channel names than SCE)
      x_gate <- rownames(cur_gate)[1]
      y_gate <- rownames(cur_gate)[2]
      x_metal <- panel_meta[panel_meta$Target == x_gate, "Metal.Tag"]
      y_metal <- panel_meta[panel_meta$clean_target == y_gate, "Metal.Tag"]
      x_original <- rownames(rowData(cur_sce)[rowData(cur_sce)[,"Metal.Tag"] == x_metal,])
      y_original <- rownames(rowData(cur_sce)[rowData(cur_sce)[,"Metal.Tag"] == y_metal,])
      
      # select current channels
      cur_counts <- as.data.frame(t(assay(cur_sce, "asinh")[c(x_original, y_original),]))
      
      # check if cells are in gate
      cur_counts$in_gate <- ifelse(cur_counts[,1] >= cur_gate[1,1] &
                                     cur_counts[,1] <= cur_gate[1,2] &
                                     cur_counts[,2] >= cur_gate[2,1] &
                                     cur_counts[,2] <= cur_gate[2,2], TRUE, FALSE)
      
      # cellIDs of cells in gate (for next gate)
      cur_cells <- rownames(cur_counts[cur_counts$in_gate == TRUE,])
      
      # update cur_sce
      cur_sce <- cur_sce[,cur_sce$cellID %in% cur_cells]
      
      # plot
      p <- ggplot() +
        geom_point(data=cur_counts, aes(x=cur_counts[,1], y=cur_counts[,2], 
                                        color=ifelse(cur_counts[,"in_gate"] == TRUE, "red", "black")),
                   alpha=ifelse(cur_counts[,"in_gate"] == TRUE, 0.5,0.1)) +
        geom_rect(data = cur_gate, aes(xmin=cur_gate[1,1], xmax=cur_gate[1,2], ymin=cur_gate[2,1],
                                       ymax=cur_gate[2,2]),
                  color="black", alpha=0.2) +
        xlab(x_gate) +
        ylab(y_gate) +
        scale_color_identity() +
        theme_bw() +
        theme(legend.position = "none") 
      p
    })
  }
  
  n <- length(plots)
  nCol <- floor(sqrt(n))
  do.call("grid.arrange", c(plots, ncol=nCol, top=cur_celltype))
}
```
